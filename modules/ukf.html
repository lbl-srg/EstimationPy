

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Unscented Kalman Filter and Smoother &mdash; EstimationPy 0.1a documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/EstimationPy_logo.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="EstimationPy 0.1a documentation" href="../index.html"/>
        <link rel="next" title="Examples" href="examples.html"/>
        <link rel="prev" title="Constant strings" href="fmu_utils/strings.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> EstimationPy
          

          
            
            <img src="../_static/EstimationPy_logo_small.png" class="logo" />
          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmu_utils.html">Utilities</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Unscented Kalman Filter and Smoother</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#notation">Notation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#footnotes">Footnotes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../applications.html">Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">Frequenty Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../publications.html">Publications and articles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributors.html">Contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../legal.html">Copyright notice</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">EstimationPy</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
    <li>Unscented Kalman Filter and Smoother</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/modules/ukf.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="unscented-kalman-filter-and-smoother">
<h1>Unscented Kalman Filter and Smoother<a class="headerlink" href="#unscented-kalman-filter-and-smoother" title="Permalink to this headline">¶</a></h1>
<p>This module contains a class that provides functionalities
for solving state estimation problems with the
Unscented Kalman Filter (UKF) and the Unscented Kalman Smoother.
The algorithm works with models that are compliant with the FMI
standard <a class="footnote-reference" href="#id17" id="id1">[3]</a>. This documentation provides information
about the method used by the class, we suggest the interested
readers to refer to <a class="reference internal" href="#julier1996" id="id2">[Julier1996]</a>, <a class="reference internal" href="#julier2002" id="id3">[Julier2002]</a>, <a class="reference internal" href="#sarkka2007" id="id4">[Sarkka2007]</a>, and <a class="reference internal" href="#sarkka2008" id="id5">[Sarkka2008]</a>
for more information on UKF and the smoother. Also, details on
the implementation of <strong>EstimationPy</strong> were presented in <a class="reference internal" href="#bonvini2014" id="id6">[Bonvini2014]</a>.</p>
<p><strong>State Estimation</strong></p>
<p>Kalman Filter (KF) <a class="reference internal" href="#haykin2001" id="id7">[Haykin2001]</a> are often used to estimate state variables.
However, as they are only applicable for linear systems, they are not
suited for our applications. For systems that are described by nonlinear differential equations,
the state estimation problem can be solved using an Extended
Kalman Filter (EKF) <a class="reference internal" href="#haykin2001" id="id8">[Haykin2001]</a>. The EKF linearizes around the current state estimate the original nonlinear model.
However, in some cases, this linearization introduces large errors in the estimated second order statistics
of the estimated state vector probability distribution <a class="reference internal" href="#wanmerwe2000" id="id9">[WanMerwe2000]</a>.
Another approach is to simulate sample paths that generate random points in the neighborhood of the old posterior
probability, for example by using Monte Carlo sampling, and adopting particle filters for the
state estimation <a class="reference internal" href="#doucet2002" id="id10">[Doucet2002]</a>.
These techniques are robust with respect to model nonlinearities, but they are computationally expensive.
The UKF faces the problem representing the state as a Gaussian random variable, the distribution of which is modeled
non parametrically using a set of points known as sigma points <a class="reference internal" href="#julier1996" id="id11">[Julier1996]</a>. Using the sigma points,
i.e., by propagating a suitable number of state realizations through the state and output equations, the mean and
the covariance of the state can be captured. The favorable properties of the UKF makes its computational cost far lower
than the Monte Carlo approaches, since a limited and deterministic number of samples
are required. Furthermore, the UKF requirements fit perfectly with the infrastructure provided by <strong>PyFMI</strong> since
it provides an interface to the FMU model that allows to set state variables, parameter and running simulations.</p>
<p><strong>The Unscented Kalman Filter</strong></p>
<p>The Unscented Kalman Filter is a model based-techniques that recursively estimates the states (and with
some modifications also parameters) of a nonlinear, dynamic, discrete-time system. This system may for example represent
a building, an HVAC plant or a chiller.
The state and output equations are</p>
<div class="math" id="equation-eqnsStateUKF">
<span class="eqno">(1)</span>\[\begin{split}\begin{align}
\mathbf{x}(t_{k+1}) &amp;= f(\mathbf{x}(t_k), \mathbf{u}(t_k), \Theta(t), t) + \mathbf{q}(t_k), \\
\mathbf{y}(t_k) &amp;= H(\mathbf{x}(t_k),\mathbf{u}(t_k), \Theta(t), t) + \mathbf{r}(t_k),
\end{align}\end{split}\]</div>
<p>with initial conditions <span class="math">\(\mathbf{x}(t_0) = \mathbf x_0\)</span>, where
<span class="math">\(f \colon \Re^n \times \Re^m \times \Re^p \times \Re \to \Re^n\)</span> is nonlinear,
<span class="math">\(\mathbf{x}(\cdot) \in \mathbb{R}^n\)</span> is the state vector, <span class="math">\(\mathbf{u}(\cdot) \in \mathbb{R}^m\)</span>
is the input vector, <span class="math">\(\Theta(\cdot) \in \mathbb{R}^p\)</span> is the parameter vector, <span class="math">\(\mathbf{q}(\cdot) \in \mathbb{R}^n\)</span>
represents the process noise (i.e. unmodeled dynamics and other uncertainties), <span class="math">\(\mathbf{y}(\cdot) \in \mathbb{R}^o\)</span>
is the output vector, <span class="math">\(H \colon \Re^n \times \Re^m \times \Re^p \times \Re \to \Re^o\)</span>
is the output measurement function and <span class="math">\(\mathbf{r}(\cdot) \in \mathbb{R}^o\)</span> is the measurement noise.</p>
<p>The UKF is based on the typical prediction-correction style methods</p>
<blockquote>
<div><ul class="simple">
<li>PREDICTION STEP: predict the state and output at time step <span class="math">\(t_{k+1}\)</span> by using the parameters and
states at <span class="math">\(t_{k}\)</span>.</li>
<li>CORRECTION STEP: given the measurements at time <span class="math">\(t_{k+1}\)</span>, update the posterior probability,
or uncertainty, of the states prediction using Bayes&#8217; rule.</li>
</ul>
</div></blockquote>
<p>The original formulation of the UKF imposes some restrictions on the model because the system needs to be
described by a system of initial-value, explicit difference equations <a href="#equation-eqnsStateUKF">(1)</a>. A second drawback is that the explicit
discrete time system cannot be used to simulate stiff systems efficiently.
The UKF should be translated in a form that is able to deal with continuous time models, possibly including events.</p>
<p>Although physical systems are often described using continuous time models, sensors routinely report
time-sampled values of the measured quantity (e.g. temperatures, pressures, positions, velocities, etc.). These
sampled signals represent the available information about the system operation and they are used
by the UKF to compute an estimation for the state variables.</p>
<p>A more natural formulation of the problem is represented by the following continuous-discrete time model</p>
<div class="math" id="equation-eqnsState">
<span class="eqno">(2)</span>\[\begin{split}\begin{align}
\frac{d \ \mathbf{x}(t)}{dt} &amp;= F(\mathbf{x}(t), \mathbf{u}(t), \Theta(t), t),  \\
\mathbf{x}(t_0) &amp;= \mathbf{x}_0, \\
\mathbf{y}(t_k) &amp;= H(\mathbf{x}(t_k),\mathbf{u}(t_k), \Theta(t),  t_k) + \mathbf{r}(t_k),
\end{align}\end{split}\]</div>
<p>where the model is defined in the continuous time domain, but the outputs are considered as discrete time
signals sampled at discrete time instants <span class="math">\(t_k\)</span>.
The original problem described in equation can be easily derived as</p>
<div class="math" id="equation-simulation">
<span class="eqno">(3)</span>\[\begin{split}\mathbf{x}(t_{k+1}) &amp;=&amp; f(\mathbf{x}(t_k), \mathbf{u}(t_k), \Theta(t_k), t_k) \nonumber \\
&amp;=&amp; \mathbf{x}(t_k) + \int_{t_k}^{t_{k+1}} F(\mathbf{x}(t), \mathbf{u}(t), \Theta(t), t)\, dt\end{split}\]</div>
<p><strong>EstimationPy</strong> implementation uses this continuous-discrete time formulation and the numerical integration is done
using PyFMI that works with a model embedded as an FMU. Despite not shown, in <a href="#equation-eqnsState">(2)</a> and <a href="#equation-simulation">(3)</a>
the model may contain events that are handled by the numerical solver provided with the PyFMI package.</p>
<p>The UKF is based on the the Unscented Transformation <a class="reference internal" href="#julier1996" id="id12">[Julier1996]</a> (UT), which uses a fixed (and typically
low) number of deterministically chosen sigma-points <a class="footnote-reference" href="#id18" id="id13">[4]</a> to express the mean and covariance of
the original distribution of the state variables <span class="math">\(\mathbf{x}(\cdot)\)</span>, exactly, under the assumption
that the uncertainties and noise are Gaussian <a class="reference internal" href="#julier1996" id="id14">[Julier1996]</a>.
These sigma-points are then propagated simulating the nonlinear model <a href="#equation-eqnsState">(2)</a> and the mean and covariance
of the state variables are estimated from them. This is significantly different from Monte Carlo approaches because
the UKF chooses the points in a deterministic way. One of the most important
properties of this approach is that if the prior estimation is distributed as a Gaussian random variable, the
sigma points are the minimum amount of information needed to compute the exact mean and covariance of the posterior
after the propagation through the nonlinear state function <a class="reference internal" href="#wanmerwe2000" id="id15">[WanMerwe2000]</a>.</p>
<div class="figure">
<img alt="../_images/StateEstimationStep.png" src="../_images/StateEstimationStep.png" />
</div>
<p>The above Figure illustrates the filtering process which we will now explain. At time <span class="math">\(t_k\)</span>, a
measurement of the outputs <span class="math">\(\mathbf{y}(t_k)\)</span>, the inputs and the previous estimation of the state are available.
Simulations are performed starting from the prior knowledge of the state <span class="math">\(\hat{\mathbf{x}}(t_{k-1})\)</span>,
using the input <span class="math">\(\mathbf{u}(t_{k-1})\)</span>. Once the results of the simulations <span class="math">\(\hat{x}_{sim}(t_k)\)</span> and
<span class="math">\(\hat{y}_{sim}(t_k)\)</span> are available, they are compared against the available measurements in order to correct
the state estimation. The corrected value (i.e. filtered) becomes the actual estimation. Because of its speed, the estimation
can provide near-real-time updates, since the time spent for simulating the system and correcting the estimation is
typically shorter than the sampling time step, in particular for building or HVAC applications, where computations
take fractions of second and sampling intervals are seconds or minutes.</p>
<p><strong>Smoothing to Improve UKF Estimation</strong></p>
<p>In this subsection, we discuss an additional refinement procedure to the UKF. The distribution
<span class="math">\(P(\mathbf{x}(t_k) \vert \mathbf{y}(t_1), \dots , \mathbf{y}(t_k))\)</span>
is the probability to observe the state vector <span class="math">\(\mathbf{x}(t_k)\)</span> at time <span class="math">\(t_k\)</span> given all the
measurements collected.
By using more data <span class="math">\(P(\mathbf{x}(t_k) \vert \mathbf{y}(t_1), \dots , \mathbf{y}(t_k), \dots \mathbf{y}(t_{k+N}))\)</span>,
the posterior distribution can be improved through recursive smoothing. Hence, the basic idea behind the recursive smoothing
process is to incorporate more measurements before providing an estimation of the state.</p>
<div class="figure">
<img alt="../_images/SmoothingStep.png" src="../_images/SmoothingStep.png" />
</div>
<p>The above Figure represents the smoothing process. While the filter works forwardly on the data available, and recursively
provides a state estimation, a smoothing procedure back-propagates the information obtained during the filtering
process, after some amount of data becomes available, in order to improved the estimation previously provided <a class="reference internal" href="#sarkka2008" id="id16">[Sarkka2008]</a>.</p>
<p>The smoothing process can be viewed as a delayed, but improved, estimation of the state variables.
The longer the acceptable delay, the bigger the improvement since more information can be used. For example if, at
a given time, a sensor provides a wrong measurement, the filter may not be aware of this and it may provide an estimation
that does not correspond to the real value (although the uncertainty bounds will still be correct). The smoother
observes the trend of the estimation will reduce this impact of the erroneous data, thus providing an estimation that is
less sensitive to measurement errors.</p>
<p><strong>Parameter Estimation</strong></p>
<p>The importance of the state estimation has been stressed, and we described the UKF and Smoother as solutions to this
problem. While state estimation is particularly important for controls, parameter estimation is important for model
calibration and fault detection and diagnostics. Consider, for example an heat exchanger. Suppose it is characterized
by one heat exchange coefficient that influences the heat transfer rate between the two fluids. During the
design of the heat exchanger it is possible to compute an approximation of it. However, it is not possible to know its
value exactly. After the heat exchanger is created, identifying the value of it is important to verify if the design
requirements have been met. Another example is real-time monitoring in which it is
continuously monitored during the operation in order to continuously check if it has been reduced by fouling and
the heat exchanger need to be serviced.</p>
<p>Continuous parameter estimation is possible by extending the capabilities of the UKF and Smoother to
estimate not just the state variable, but also the parameters of the system. The approach is to include the parameter
in an augmented state <span class="math">\(\mathbf{x}^A(\cdot)\)</span>, defined as</p>
<div class="math">
\[\mathbf{x}^A(\cdot) = \left [ \mathbf{x}(\cdot) \ \ \ \mathbf{x}^P(\cdot) \right ]^T,\]</div>
<p>where <span class="math">\(\mathbf{x}^P(\cdot) \subseteq \Theta(\cdot)\)</span> is a vector containing a subset of the full parameter
vector <span class="math">\(\Theta(\cdot)\)</span> to be estimated. The new components of the state variables need a function that
describe their dynamics. Since in the normal operation, these values are constant, the associated dynamic is</p>
<div class="math">
\[\frac{d \ \mathbf{x}^P(t) }{dt} = \mathbf{0},\]</div>
<p>where <span class="math">\(\mathbf{0}\)</span> is a null vector. These null dynamics have to be added <a href="#equation-eqnsState">(2)</a>. The result
is a new continuous-discrete time system</p>
<div class="math">
\[\begin{split}\begin{align}
\frac{d \ \mathbf{x}^A(t)}{dt} &amp;= F_A(\mathbf{x}^A(t), \mathbf{u}(t), \Theta(t), t)  \\
\mathbf{y}(t_k) &amp;= H(\mathbf{x}^A(t_k),\mathbf{u}(t_k), \Theta(t_k),  t_k) + \mathbf{r}(t_k),
\end{align}\end{split}\]</div>
<p>with</p>
<div class="math">
\[\begin{split}F_A(\mathbf{x}^A(t), \mathbf{u}(t), \Theta(t), t) =
\begin{bmatrix}
F(\mathbf{x}(t), \mathbf{u}(t), \Theta(t), t) \\
\mathbf{0}
\end{bmatrix}\end{split}\]</div>
<p>Note that augmenting the state variables leads to a nonlinear state equation even if
<span class="math">\(F(\cdot, \cdot, \cdot, \cdot)\)</span> is a linear function.
Therefore, for parameter estimation, a nonlinear filtering and smoothing technique is required.</p>
<div class="section" id="notation">
<h2>Notation<a class="headerlink" href="#notation" title="Permalink to this headline">¶</a></h2>
<p>The superscript <span class="math">\(^{(i)}\)</span> indicates that the quantity is related to the i-th sigma point,
<span class="math">\(w_m^{(i)}\)</span> and <span class="math">\(w_c^{(i)}\)</span> are the weights associated to the <span class="math">\(i-th\)</span>
sigma point, <span class="math">\(N\)</span> is the dimension of the state vector <span class="math">\(\mathbf{x}(\cdot)\)</span>, and
<span class="math">\([\cdot]_i\)</span> is an operator that if applied to a matrix <span class="math">\(A\)</span> returns its <span class="math">\(i-th\)</span> column.
Vectors are indicated with bold characters.</p>
<span class="target" id="module-estimationpy.ukf.ukf_fmu"></span><dl class="class">
<dt id="estimationpy.ukf.ukf_fmu.UkfFmu">
<em class="property">class </em><code class="descclassname">estimationpy.ukf.ukf_fmu.</code><code class="descname">UkfFmu</code><span class="sig-paren">(</span><em>model</em>, <em>n_proc=3</em><span class="sig-paren">)</span><a class="headerlink" href="#estimationpy.ukf.ukf_fmu.UkfFmu" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents an Unscented Kalman Filter (UKF) that can be used for the 
state and parameter estimation of nonlinear dynamic systems represented
by FMU models.</p>
<p>This class uses an object ot type <a class="reference internal" href="fmu_utils/model.html#estimationpy.fmu_utils.model.Model" title="estimationpy.fmu_utils.model.Model"><code class="xref py py-class docutils literal"><span class="pre">estimationpy.fmu_utils.model.Model</span></code></a> to 
represent the system. The model once instantiated and configured,
already contains the data series associated to the measured inputs and outputs,
the list of states and parameters to estimates, covariances, and constraints
for the estimated variables.
See <a class="reference internal" href="fmu_utils/model.html#module-estimationpy.fmu_utils.model" title="estimationpy.fmu_utils.model"><code class="xref py py-mod docutils literal"><span class="pre">estimationpy.fmu_utils.model</span></code></a> for more information.</p>
<p>The class internally uses an <a class="reference internal" href="fmu_utils/fmu_pool.html#estimationpy.fmu_utils.fmu_pool.FmuPool" title="estimationpy.fmu_utils.fmu_pool.FmuPool"><code class="xref py py-class docutils literal"><span class="pre">estimationpy.fmu_utils.fmu_pool.FmuPool</span></code></a> to 
run simulations in parallel over multiple processors. Please have a look to
<a class="reference internal" href="fmu_utils/fmu_pool.html#module-estimationpy.fmu_utils.fmu_pool" title="estimationpy.fmu_utils.fmu_pool"><code class="xref py py-mod docutils literal"><span class="pre">estimationpy.fmu_utils.fmu_pool</span></code></a> for more information.</p>
<dl class="method">
<dt id="estimationpy.ukf.ukf_fmu.UkfFmu.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>n_proc=3</em><span class="sig-paren">)</span><a class="headerlink" href="#estimationpy.ukf.ukf_fmu.UkfFmu.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor of the class that initializes an object that can be used to solve
state and parameter estimation problems by using the UKF and smoothing algorithms.
The constructor requires a model representing the systems which states and/or parameters
will be estimated.</p>
<p>The method performs the following steps</p>
<ol class="arabic simple">
<li>creates a reference to the models and instantiales an object of type         <a class="reference internal" href="fmu_utils/fmu_pool.html#estimationpy.fmu_utils.fmu_pool.FmuPool" title="estimationpy.fmu_utils.fmu_pool.FmuPool"><code class="xref py py-class docutils literal"><span class="pre">estimationpy.fmu_utils.fmu_pool.FmuPool</span></code></a> for running simulations in parallel,</li>
<li>compute the number of sigma points to be used,</li>
<li>define the parameters of the filter,</li>
<li>compute the weights associated to each sigma point,</li>
<li>initialize the constraints on the observed state variables and estimated        parameters,</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>model</strong> (<a class="reference internal" href="fmu_utils/model.html#estimationpy.fmu_utils.model.Model" title="estimationpy.fmu_utils.model.Model"><em>estimationpy.fmu_utils.model.Model</em></a>) &#8211; the model which states and/or parameters
have to be estimated.</li>
<li><strong>n_proc</strong> (<em>int</em>) &#8211; a positive integer that defines the number of processes that are created
when the simulations are run. Make sure this value is equal to 1 if the filtering or smoothing
are executed as part of a Celery task. By default this value is equal to the number of 
available processors minus one.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>ValueError</strong> &#8211; The method raises an exception if the model associated to the filter
does not have state or parameters to be estimated.</li>
<li><strong>Exception</strong> &#8211; The method raises an exception if there are not measured outputs, the 
number of states to estimate is higher than the total number of states, of the number of
parameters to estimate is invalid.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="estimationpy.ukf.ukf_fmu.UkfFmu.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#estimationpy.ukf.ukf_fmu.UkfFmu.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method returns a string representation of the object with
a brief description containing</p>
<ul class="simple">
<li>name of the model,</li>
<li>total number of states,</li>
<li>total number of observed states,</li>
<li>total number of parameters to estimate, and</li>
<li>number of measured outputs used to perform the estimation.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">string representation of the object</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">string</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="estimationpy.ukf.ukf_fmu.UkfFmu.average_proj">
<code class="descname">average_proj</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#estimationpy.ukf.ukf_fmu.UkfFmu.average_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>This function averages the projection of the sigma points.
The function can be used to compute the average of both the state vector or
the measured outputs. The weigths vetcor used is <span class="math">\(\mathbf{w}_m\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> (<em>np.ndarray</em>) &#8211; the vector to average <span class="math">\(\mathbf{x}\)</span></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the average of the vector computed as <span class="math">\(\mathbf{w}_m^T \mathbf{x}\)</span></td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">numpy.ndarray</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="estimationpy.ukf.ukf_fmu.UkfFmu.chol_update">
<code class="descname">chol_update</code><span class="sig-paren">(</span><em>L</em>, <em>X</em>, <em>W</em><span class="sig-paren">)</span><a class="headerlink" href="#estimationpy.ukf.ukf_fmu.UkfFmu.chol_update" title="Permalink to this definition">¶</a></dt>
<dd><p>This method computes the Cholesky update of a matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>L</strong> (<em>numpy.ndarray</em>) &#8211; lower triangular matrix computed with QR factorization</li>
<li><strong>X</strong> (<em>numpy.array</em>) &#8211; vector used to compute the covariance matrix. It can either be a vector
representing the deviation of the state from its average, or the deviation from an output
from its average.</li>
<li><strong>W</strong> (<em>numpy.array</em>) &#8211; vector of weights</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the square root matrix computed using the Cholesky update</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="estimationpy.ukf.ukf_fmu.UkfFmu.compute_C_x_x">
<code class="descname">compute_C_x_x</code><span class="sig-paren">(</span><em>x_new</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#estimationpy.ukf.ukf_fmu.UkfFmu.compute_C_x_x" title="Permalink to this definition">¶</a></dt>
<dd><p>This method computes the state-state cross covariance matrix <span class="math">\(C_{xx}\)</span>
between the old state <span class="math">\(\mathbf{x}\)</span> and the new state <span class="math">\(\mathbf{x}_{new}\)</span>.</p>
<blockquote>
<div><div class="math">
\[C_{xx} = \sum_{i=0}^{2n+1} w_c^{(i)} \left ( \mathbf{x}_{new}^{(i)} - \boldsymbol{\mu}_{new} \right )              \left ( \mathbf{x}^{(i)} - \boldsymbol{\mu}) \right )^T\]</div>
</div></blockquote>
<p>where <span class="math">\(\boldsymbol{\mu}\)</span> and <span class="math">\(\boldsymbol{\mu}_{new}\)</span> are the average
of the vectors <span class="math">\(\mathbf{x}\)</span> and <span class="math">\(\mathbf{x}_{new}\)</span> over all the
sigma points <span class="math">\(i\)</span>.</p>
<p><strong>Notes:</strong>
This is method is used by the smoothing process because during the smoothing
the averages are not directly available and thus <a class="reference internal" href="#estimationpy.ukf.ukf_fmu.UkfFmu.compute_cov_x_x" title="estimationpy.ukf.ukf_fmu.UkfFmu.compute_cov_x_x"><code class="xref py py-func docutils literal"><span class="pre">compute_cov_x_x()</span></code></a> can&#8217;t be used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x_new</strong> (<em>numpy.array</em>) &#8211; vector that contains the full state of the system (estimated, not estimated states, as well
the estimated parameters), this vector can be seen as the propagated sigma points</li>
<li><strong>x</strong> (<em>numpy.array</em>) &#8211; vector containing initial states before the progatation</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">state-state covariance matrix <span class="math">\(C_{xx}\)</span></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="estimationpy.ukf.ukf_fmu.UkfFmu.compute_P">
<code class="descname">compute_P</code><span class="sig-paren">(</span><em>x</em>, <em>x_avg</em>, <em>Q</em><span class="sig-paren">)</span><a class="headerlink" href="#estimationpy.ukf.ukf_fmu.UkfFmu.compute_P" title="Permalink to this definition">¶</a></dt>
<dd><p>This method computes the state covariance matrix <span class="math">\(P\)</span> as</p>
<div class="math">
\[P = Q + \sum_{i=0}^{2n+1} w_c^{(i)} \left ( \mathbf{x}^{(i)} - \boldsymbol{\mu} \right )              \left ( \mathbf{x}^{(i)} - \boldsymbol{\mu} \right )^T\]</div>
<p>where <span class="math">\(\boldsymbol{\mu}\)</span> is the average of the vector <span class="math">\(\mathbf{x}\)</span>
among the different sigma points.
The method removes the not observed states from <span class="math">\(\mathbf{x}\)</span> and computes
the covariance matrix <span class="math">\(\mathbf{P}\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> (<em>numpy.array</em>) &#8211; vector that conatins the estimated states of the system as well
the estimated parameters. This vector can be seen as the propagated sigma points.</li>
<li><strong>x_avg</strong> (<em>numpy.array</em>) &#8211; vector that contains the average of the propagated sigma points</li>
<li><strong>Q</strong> (<em>numpy.ndarray</em>) &#8211; covariance matrix</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="estimationpy.ukf.ukf_fmu.UkfFmu.compute_S">
<code class="descname">compute_S</code><span class="sig-paren">(</span><em>x_proj</em>, <em>x_ave</em>, <em>sqrt_Q</em>, <em>w=None</em><span class="sig-paren">)</span><a class="headerlink" href="#estimationpy.ukf.ukf_fmu.UkfFmu.compute_S" title="Permalink to this definition">¶</a></dt>
<dd><p>This method computes the squared root covariance matrix using the QR decomposition
combined with a Cholesky update.
The matrix returned by this method is upper triangular.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x_proj</strong> (<em>numpy.array</em>) &#8211; projected full state vector</li>
<li><strong>x_avg</strong> (<em>numpy.array</em>) &#8211; average of the full state vector</li>
<li><strong>sqrt_Q</strong> (<em>numpy.ndarray</em>) &#8211; square root process covariance matrix</li>
<li><strong>w</strong> (<em>numpy.array</em>) &#8211; vector that contains the weights to use during the
update. If not specified the method uses the weights automatically computed
by the filter.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the square root of the updated state covariance matrix. The matrix is 
upper triangular.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">nunmpy.ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="estimationpy.ukf.ukf_fmu.UkfFmu.compute_S_y">
<code class="descname">compute_S_y</code><span class="sig-paren">(</span><em>y_proj</em>, <em>y_ave</em>, <em>sqrt_R</em><span class="sig-paren">)</span><a class="headerlink" href="#estimationpy.ukf.ukf_fmu.UkfFmu.compute_S_y" title="Permalink to this definition">¶</a></dt>
<dd><p>This method computes the squared root covariance matrix using the QR decomposition
combined with a Cholesky update.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>y_proj</strong> (<em>numpy.array</em>) &#8211; projected measured output vector</li>
<li><strong>y_avg</strong> (<em>numpy.array</em>) &#8211; average of the measured output vector</li>
<li><strong>sqrt_R</strong> (<em>numpy.ndarray</em>) &#8211; square root process covariance matrix</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the square root of the updated output covariance matrix</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">nunmpy.ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="estimationpy.ukf.ukf_fmu.UkfFmu.compute_cov_x_x">
<code class="descname">compute_cov_x_x</code><span class="sig-paren">(</span><em>x_new</em>, <em>x_new_avg</em>, <em>x</em>, <em>x_avg</em><span class="sig-paren">)</span><a class="headerlink" href="#estimationpy.ukf.ukf_fmu.UkfFmu.compute_cov_x_x" title="Permalink to this definition">¶</a></dt>
<dd><p>This method computes the state-state cross covariance matrix <span class="math">\(C_{xx}\)</span>.
The different states are the state before and after the propagation.</p>
<div class="math">
\[C_{xx} = \sum_{i=0}^{2n+1} w_c^{(i)} \left ( \mathbf{x}_{new}^{(i)} - \boldsymbol{\mu}_{new} \right )              \left ( \mathbf{x}^{(i)} - \boldsymbol{\mu}) \right )^T\]</div>
<p>where <span class="math">\(\boldsymbol{\mu}\)</span> and <span class="math">\(\boldsymbol{\mu}_{new}\)</span> are the average
of the vectors <span class="math">\(\mathbf{x}\)</span> and <span class="math">\(\mathbf{x}_{new}\)</span> over all the
sigma points <span class="math">\(i\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x_new</strong> (<em>numpy.array</em>) &#8211; vector that contains the estimated states of the system as well
the estimated parameters. This vector can be seen as the propagated sigma points.</li>
<li><strong>x_new_avg</strong> (<em>numpy.array</em>) &#8211; vector that contains the average of the propagated sigma points</li>
<li><strong>x</strong> (<em>numpy.array</em>) &#8211; vector containing initial states before the progatation</li>
<li><strong>x_avg</strong> (<em>numpy.array</em>) &#8211; vector containing the average of the initial state before the propagation</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">state-state covariance matrix <span class="math">\(C_{xx}\)</span></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="estimationpy.ukf.ukf_fmu.UkfFmu.compute_cov_x_y">
<code class="descname">compute_cov_x_y</code><span class="sig-paren">(</span><em>x</em>, <em>x_avg</em>, <em>y</em>, <em>y_avg</em><span class="sig-paren">)</span><a class="headerlink" href="#estimationpy.ukf.ukf_fmu.UkfFmu.compute_cov_x_y" title="Permalink to this definition">¶</a></dt>
<dd><p>This method computes the cross covariance matrix <span class="math">\(C_{xy}\)</span>
between the states and measured outputs vectors.</p>
<div class="math">
\[C_{xy} = \sum_{i=0}^{2n+1} w_c^{(i)} \left ( \mathbf{x}_{new}^{(i)} - \boldsymbol{\mu}_{new} \right )              \left ( \mathbf{y}^{(i)} - \hat{\mathbf{y}} \right )^T\]</div>
<p>where <span class="math">\(\boldsymbol{\mu}\)</span> and <span class="math">\(\hat{\mathbf{y}}\)</span> are the average
of the vectors <span class="math">\(\mathbf{x}\)</span> and <span class="math">\(\mathbf{y}\)</span> over all the
sigma points <span class="math">\(i\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>numpy.array</em>) &#8211; vector that conatins the estimated states of the system as well
the estimated parameters. This vector can be seen as the propagated sigma points.</li>
<li><strong>x_avg</strong> (<em>numpy.array</em>) &#8211; vector that contains the average of the propagated sigma points</li>
<li><strong>y</strong> (<em>numpy.array</em>) &#8211; vector containing the measured outputs</li>
<li><strong>y_avg</strong> (<em>numpy.array</em>) &#8211; vector containing the average of the measured outputs</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">state-outputs covariance matrix <span class="math">\(C_{xy}\)</span></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="estimationpy.ukf.ukf_fmu.UkfFmu.compute_cov_y">
<code class="descname">compute_cov_y</code><span class="sig-paren">(</span><em>y</em>, <em>y_avg</em>, <em>R</em><span class="sig-paren">)</span><a class="headerlink" href="#estimationpy.ukf.ukf_fmu.UkfFmu.compute_cov_y" title="Permalink to this definition">¶</a></dt>
<dd><p>This method computes the output covariance matrix <span class="math">\(C_y\)</span>
that is the covariance matrix of the outputs, corrected
by the measurements covariance matrix <span class="math">\(R\)</span>.</p>
<div class="math">
\[C_{y} = R + \sum_{i=0}^{2n+1} w_c^{(i)} \left (  \mathbf{y}^{(i)} - \hat{\mathbf{y}} \right )              \left ( \mathbf{y}^{(i)} - \hat{\mathbf{y}} \right )^T\]</div>
<p>where <span class="math">\(\hat{\mathbf{y}}\)</span> is the average
of the vector <span class="math">\(\mathbf{y}\)</span> over all the sigma points <span class="math">\(i\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>y</strong> (<em>numpy.array</em>) &#8211; vector containing the measured outputs</li>
<li><strong>y_avg</strong> (<em>numpy.array</em>) &#8211; vector containing the average of the mesaured outputs</li>
<li><strong>R</strong> (<em>numpy.ndarray</em>) &#8211; measurements covariance matrix</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">output covariance matrix <span class="math">\(C_y\)</span></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="estimationpy.ukf.ukf_fmu.UkfFmu.compute_sigma_points">
<code class="descname">compute_sigma_points</code><span class="sig-paren">(</span><em>x</em>, <em>pars</em>, <em>sqrtP</em><span class="sig-paren">)</span><a class="headerlink" href="#estimationpy.ukf.ukf_fmu.UkfFmu.compute_sigma_points" title="Permalink to this definition">¶</a></dt>
<dd><p>This method computes the sigma points, its inputs are</p>
<ul class="simple">
<li><span class="math">\(\mathbf{x}\)</span>  &#8211; the state vector around the points will be propagated,</li>
<li><span class="math">\(\mathbf{x}^P\)</span>  &#8211; the vector of parameters that are estimated,</li>
<li><span class="math">\(\sqrt{P}\)</span> &#8211; the square root of the state covariance matrix <span class="math">\(P\)</span>,          this matrix is used to spread the sigma points before their propagation.</li>
</ul>
<p>The sigma points are computed as</p>
<div class="math">
\[\begin{split}\mathbf{x}^{A \, (0)} &amp;=&amp; \, \boldsymbol{\mu} , \\
\mathbf{x}^{A \, (i)} &amp;=&amp; \, \boldsymbol{\mu} + \left [ \sqrt{(n+\lambda) P} \right ]_i \ , \ i=1 \dots n , \\
\mathbf{x}^{A \, (i)} &amp;=&amp; \, \boldsymbol{\mu} - \left [ \sqrt{(n+\lambda) P} \right ]_{i-n} \ , \ i=n+1 \dots 2n\end{split}\]</div>
<p>where <span class="math">\(\boldsymbol{\mu}\)</span> is the average of the vector <span class="math">\(\mathbf{x}^A\)</span>, defined as</p>
<div class="math">
\[\mathbf{x}^A = \left[ \mathbf{x} \ , \ \mathbf{x}^P \right]\]</div>
<p>and <span class="math">\(\boldsymbol{\mu}\)</span> is its average.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>numpy.array</em>) &#8211; vector containing the estimated states,</li>
<li><strong>pars</strong> (<em>numpy.array</em>) &#8211; vector containing the estimated parameters,</li>
<li><strong>sqrtP</strong> (<em>numpy.ndarray</em>) &#8211; square root of the covariance matrix <span class="math">\(P\)</span></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">a matrix that contains the sigma points, each row is a sigma point that is          a vector of state and parameters to be evaluated.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">numpy.ndarray</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Raises ValueError:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last">The method raises a value error if the input parameters          <code class="docutils literal"><span class="pre">x</span></code> or <code class="docutils literal"><span class="pre">pars</span></code> do not respect the dimensions of the observed states and estimated          parameters.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="estimationpy.ukf.ukf_fmu.UkfFmu.compute_weights">
<code class="descname">compute_weights</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#estimationpy.ukf.ukf_fmu.UkfFmu.compute_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>This method computes the vector of weights used by the UKF filter.
These weights are associated to each sigma point and are used to
compute the mean value and the covariance of the estimation at each step
of the fitering process.</p>
<p>There are two types of weigth vectors</p>
<ul class="simple">
<li><span class="math">\(\mathbf{w}_m\)</span> is used to compute the mean value</li>
<li><span class="math">\(\mathbf{w}_c\)</span> is used to compute the covariance</li>
</ul>
<div class="math">
\[\begin{split}w_m^{(0)} &amp;=&amp; \lambda / (N + \lambda) \\
w_c^{(0)} &amp;=&amp; \lambda / (N + \lambda) + (1 - \alpha^2 + \beta) , \\
w_m^{(i)} &amp;=&amp; 1 / 2(N + \lambda) \ , \ i=1 \dots 2N , \\
w_c^{(i)} &amp;=&amp; 1 / 2(N + \lambda) \ , \ i=1 \dots 2N\end{split}\]</div>
<p>where <span class="math">\(N\)</span> is the length os the state vector. In our case it is equal to 
total number of states and parameters estimated.</p>
</dd></dl>

<dl class="method">
<dt id="estimationpy.ukf.ukf_fmu.UkfFmu.constrained_state">
<code class="descname">constrained_state</code><span class="sig-paren">(</span><em>x_A</em><span class="sig-paren">)</span><a class="headerlink" href="#estimationpy.ukf.ukf_fmu.UkfFmu.constrained_state" title="Permalink to this definition">¶</a></dt>
<dd><p>This method applies the constraints associated to the state variables and
parameters being estimated to the state vector <span class="math">\(\mathbf{x}^A\)</span>.
The constraints are applied only to the states and parameters estimated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x_A</strong> (<em>numpy.ndarray</em>) &#8211; vector <span class="math">\(\mathbf{x}^A\)</span> containing the states to be constrained</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the constrained version of <span class="math">\(\mathbf{x}^A\)</span></td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">numpy.ndarray</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Raises ValueError:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">the method raises an exception if the parameter vector has a shape
that does not correspond to the total number of states and parameters to estimate.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="estimationpy.ukf.ukf_fmu.UkfFmu.filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em>, <em>sqrt_P=None</em>, <em>sqrt_Q=None</em>, <em>sqrt_R=None</em>, <em>for_smoothing=False</em><span class="sig-paren">)</span><a class="headerlink" href="#estimationpy.ukf.ukf_fmu.UkfFmu.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>This method starts the filtering process. The filtering process
is a loop of multiple calls of the basic method <a class="reference internal" href="#estimationpy.ukf.ukf_fmu.UkfFmu.ukf_step" title="estimationpy.ukf.ukf_fmu.UkfFmu.ukf_step"><code class="xref py py-func docutils literal"><span class="pre">ukf_step()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>start</strong> (<em>datetime.datetime</em>) &#8211; time stamp that indicates the beginning of the
filtering period</li>
<li><strong>stop</strong> (<em>datetime.datetime</em>) &#8211; time stamp that identifies the end of the
filtering period</li>
<li><strong>sqrt_P</strong> (<em>numpy.ndarray</em>) &#8211; a matrix that can be used to initialize the square root 
of the augmented state covariance matrix. If equal to None, the method uses
a diagonal matrix that contains the standard deviation of each states and parameters.</li>
<li><strong>sqrt_Q</strong> (<em>numpy.ndarray</em>) &#8211; a matrix that is used to represent the process noise.
This matrix is in square root form and is kept constant while the algorithm
is executed. If equal to None, the method uses
a diagonal matrix that contains the standard deviation of each states and parameters.</li>
<li><strong>sqrt_R</strong> (<em>numpy.ndarray</em>) &#8211; a matrix that is used to represent the measurement noise.
This matrix is in square root form and is kept constant while the algorithm runs.
If equal to None, the method uses a diagonal matrix that contains the standard deviation
of the measured outputs as elements.</li>
<li><strong>for_smoothing</strong> (<em>bool</em>) &#8211; Boolean flag that indicates if the data computed by this method
will be used by a smoother. If True, the function returns more data so the smoother
can use them.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p>the method returns a tuple containinig</p>
<ul class="simple">
<li>time vector containing the instants at which the filter
estimated the states and/or parameters,</li>
<li>the estimated states and parameters,</li>
<li>the square root of the covariance matrix of the estimated states and parameters,</li>
<li>the measured outputs,</li>
<li>the square root of the covariance matrix of the outputs,</li>
<li>the full outputs of the model</li>
</ul>
<p>if <code class="docutils literal"><span class="pre">for_smoothing</span> <span class="pre">==</span> <span class="pre">True</span></code>, the following variables are added</p>
<ul class="simple">
<li>the full states of the model,</li>
<li>the square root of the process covariance matrix,</li>
<li>the square root of the measurements covariance matrix</li>
</ul>
<p><strong>Note:</strong> please note that every vector and matrix returned by this method is a list that
contains the vector/matrices for each time stamp of the filtering process.</p>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">tuple</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Raises Exception:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last">The method raises an exception if there are problem during the filtering process,
e.g., numerical problems regarding the estimation.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="estimationpy.ukf.ukf_fmu.UkfFmu.filter_and_smooth">
<code class="descname">filter_and_smooth</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em><span class="sig-paren">)</span><a class="headerlink" href="#estimationpy.ukf.ukf_fmu.UkfFmu.filter_and_smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>This method executes the filtering and smoothing of the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>start</strong> (<em>datetime.datetime</em>) &#8211; start date and time of the filtering + smoothing process.</li>
<li><strong>stop</strong> (<em>datetime.datetime</em>) &#8211; end date and time of the filtering + smoothing process.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p>the method returns a tuple containinig</p>
<ul class="simple">
<li>time vector containing the instants at which the filter + smoother
estimated the states and/or parameters,</li>
<li>the estimated states and parameters computed by the UKF,</li>
<li>the square root of the covariance matrix of the estimated states and parameters computed by the UKF,</li>
<li>the measured outputs computed by the UKF,</li>
<li>the square root of the covariance matrix of the outputs computed by the UKF,</li>
<li>the full outputs of the model computed by the UKF</li>
<li>the estimated states and parameters computed by the smoother,</li>
<li>the square root of the covariance matrix of the estimated states and parameters computed by the smoother,</li>
<li>the full outputs of the model computed by the smoother,</li>
</ul>
<p><strong>Note:</strong> please note that every vector and matrix returned by this method is a list that
contains the vector/matrices for each time stamp of the filtering process.</p>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">tuple</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Raises Exception:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last">The method raises an exception if there are problem during the filtering or smoothing process,
e.g., numerical problems regarding the estimation.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="estimationpy.ukf.ukf_fmu.UkfFmu.find_closest_matches">
<em class="property">static </em><code class="descname">find_closest_matches</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em>, <em>time</em><span class="sig-paren">)</span><a class="headerlink" href="#estimationpy.ukf.ukf_fmu.UkfFmu.find_closest_matches" title="Permalink to this definition">¶</a></dt>
<dd><p>This function finds the closest matched to <code class="docutils literal"><span class="pre">start</span></code> and <code class="docutils literal"><span class="pre">stop</span></code> among
the elements of the parameter <code class="docutils literal"><span class="pre">time</span></code>.</p>
<p><strong>Note:</strong>
The function assumes that parameter <code class="docutils literal"><span class="pre">time</span></code> is sorted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>start</strong> (<em>datetime.datetime</em>) &#8211; the initial time stamp</li>
<li><strong>start</strong> &#8211; the final time stamp</li>
<li><strong>time</strong> (<em>list</em>) &#8211; a datetime index for the data (both inputs and outputs)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">a tuple that contains the selected start and stop elements from <code class="docutils literal"><span class="pre">time</span></code>
that are the closest to <code class="docutils literal"><span class="pre">start</span></code> and <code class="docutils literal"><span class="pre">stop</span></code>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">tuple</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="estimationpy.ukf.ukf_fmu.UkfFmu.get_ukf_params">
<code class="descname">get_ukf_params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#estimationpy.ukf.ukf_fmu.UkfFmu.get_ukf_params" title="Permalink to this definition">¶</a></dt>
<dd><p>This method returns a tuple containing the parameters of the UKF.
The parameters in the return tuple are</p>
<ul class="simple">
<li><span class="math">\(\alpha\)</span>,</li>
<li><span class="math">\(\beta\)</span>,</li>
<li><span class="math">\(k\)</span>,</li>
<li><span class="math">\(\lambda\)</span>,</li>
<li><span class="math">\(\sqrt{C}\)</span>,</li>
<li><span class="math">\(N\)</span></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">tuple containing the parameters of the UKF</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">tuple</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="estimationpy.ukf.ukf_fmu.UkfFmu.get_weights">
<code class="descname">get_weights</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#estimationpy.ukf.ukf_fmu.UkfFmu.get_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>This method returns a tuple that contains the vectors <span class="math">\(\mathbf{w}_m\)</span> and <span class="math">\(\mathbf{w}_c\)</span>
containing the weights used by the UKF. Each vector is a <strong>numpy.array</strong>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">tuple with first element <span class="math">\(\mathbf{w}_m\)</span>, and second <span class="math">\(\mathbf{w}_c\)</span></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">tuple</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="estimationpy.ukf.ukf_fmu.UkfFmu.set_default_ukf_params">
<code class="descname">set_default_ukf_params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#estimationpy.ukf.ukf_fmu.UkfFmu.set_default_ukf_params" title="Permalink to this definition">¶</a></dt>
<dd><p>This method initializes the parameters of the UKF to their
default values and then computes the weights by calling the method
<a class="reference internal" href="#estimationpy.ukf.ukf_fmu.UkfFmu.compute_weights" title="estimationpy.ukf.ukf_fmu.UkfFmu.compute_weights"><code class="xref py py-func docutils literal"><span class="pre">compute_weights()</span></code></a>. The default values are</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">parameter name</th>
<th class="head">value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><span class="math">\(\alpha\)</span></td>
<td>0.01</td>
</tr>
<tr class="row-odd"><td><span class="math">\(\beta\)</span></td>
<td>1</td>
</tr>
<tr class="row-even"><td><span class="math">\(k\)</span></td>
<td>2</td>
</tr>
<tr class="row-odd"><td><span class="math">\(\lambda\)</span></td>
<td><span class="math">\(2 \alpha (N + k) - N\)</span></td>
</tr>
<tr class="row-even"><td><span class="math">\(\sqrt{C}\)</span></td>
<td><span class="math">\(\alpha \sqrt{N+k}\)</span></td>
</tr>
</tbody>
</table>
<p>where <span class="math">\(N\)</span> is the total number of states and parameter to estimate.</p>
</dd></dl>

<dl class="method">
<dt id="estimationpy.ukf.ukf_fmu.UkfFmu.set_ukf_params">
<code class="descname">set_ukf_params</code><span class="sig-paren">(</span><em>alpha=0.57735026918962584</em>, <em>beta=2</em>, <em>k=None</em><span class="sig-paren">)</span><a class="headerlink" href="#estimationpy.ukf.ukf_fmu.UkfFmu.set_ukf_params" title="Permalink to this definition">¶</a></dt>
<dd><p>This method allows to set the parameters of the UKF.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>alpha</strong> (<em>float</em>) &#8211; The parameter <span class="math">\(\alpha\)</span> of the UKF</li>
<li><strong>beta</strong> (<em>float</em>) &#8211; The parameter <span class="math">\(\beta\)</span> of the UKF</li>
<li><strong>k</strong> (<em>float</em>) &#8211; The parameter <span class="math">\(k\)</span> of the UKF</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>given these parameters, the method computes</p>
<div class="math">
\[\begin{split}\lambda  &amp;= 2 \alpha (N + k) - N \\
\sqrt{C} &amp;= \alpha \sqrt{N+k}\end{split}\]</div>
<p>where <span class="math">\(N\)</span> is the total number of states and parameters to estimate.</p>
</dd></dl>

<dl class="method">
<dt id="estimationpy.ukf.ukf_fmu.UkfFmu.sigma_point_proj">
<code class="descname">sigma_point_proj</code><span class="sig-paren">(</span><em>x_A</em>, <em>t_old</em>, <em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#estimationpy.ukf.ukf_fmu.UkfFmu.sigma_point_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>This method, given a set of sigma points represented by the vector <span class="math">\(\mathbf{x}^A\)</span>,
propagates them using the state transition function. The state transition function is 
a simulation run from time <span class="math">\(t_{old}\)</span> to <span class="math">\(t\)</span>.
The simulations are managed by a <strong>FmuPool</strong> object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x_A</strong> (<em>numpy.ndarray</em>) &#8211; the vector containing the sigma points to propagate</li>
<li><strong>t_old</strong> (<em>datetime.datetime</em>) &#8211; the start time for the simulation that computes the propagations</li>
<li><strong>t</strong> (<em>datetime.datetime</em>) &#8211; the final time for the simulation that computes the propagations</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p>a tuple that contains</p>
<ul class="simple">
<li>the projected states (only the estimated ones + estimated parameters),</li>
<li>the projected outputs (only the measured ones),</li>
<li>the full projected states (both estimated and not),</li>
<li>the full projected outputs (either measured or not).</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">tuple</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Note:</strong>
If for any reason the results of the simulation pool is an empty dictionary,
the method tries again to run the simulations up to the maximum number
of simulations allowed <code class="docutils literal"><span class="pre">MAX_RUN</span></code>. By default <code class="docutils literal"><span class="pre">MAX_RUN</span> <span class="pre">=</span> <span class="pre">3</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="estimationpy.ukf.ukf_fmu.UkfFmu.square_root">
<code class="descname">square_root</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#estimationpy.ukf.ukf_fmu.UkfFmu.square_root" title="Permalink to this definition">¶</a></dt>
<dd><p>This method computes the square root of a square matrix <span class="math">\(A\)</span>.
The method uses the Cholesky factorization provided by the linear algebra
package in <strong>numpy</strong>. The matrix returned is a lower triangular 
matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>A</strong> (<em>numpy.ndarray</em>) &#8211; square matrix <span class="math">\(A\)</span></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">square root of math:<cite>A</cite>, such that <span class="math">\(S S^T = A\)</span>. The
matrix is lower triangular.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">numpy.ndarray</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="estimationpy.ukf.ukf_fmu.UkfFmu.ukf_step">
<code class="descname">ukf_step</code><span class="sig-paren">(</span><em>x</em>, <em>sqrtP</em>, <em>sqrtQ</em>, <em>sqrtR</em>, <em>t_old</em>, <em>t</em>, <em>z=None</em><span class="sig-paren">)</span><a class="headerlink" href="#estimationpy.ukf.ukf_fmu.UkfFmu.ukf_step" title="Permalink to this definition">¶</a></dt>
<dd><p>This method implements the basic step that constitutes the UKF algorithm.
The main steps are two:</p>
<ol class="arabic simple">
<li>predition of the new state by projection,</li>
<li>correction of the projection using the measurements</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>numpy.array</em>) &#8211; initial state vector</li>
<li><strong>sqrtP</strong> (<em>numpy.ndarray</em>) &#8211; square root of the process covariance matrix</li>
<li><strong>sqrtQ</strong> (<em>numpy.ndarray</em>) &#8211; square root of the process covariance matrix</li>
<li><strong>sqrtR</strong> (<em>numpy.ndarray</em>) &#8211; square root of the measurements/outputs covariance matrix</li>
<li><strong>t_old</strong> (<em>datetime.datetime</em>) &#8211; initial time for running the simulaiton</li>
<li><strong>t</strong> (<em>datetime.datetime</em>) &#8211; final time for runnign the simulation</li>
<li><strong>z</strong> (<em>numpy.array</em>) &#8211; measured outputs at time <code class="docutils literal"><span class="pre">t</span></code>. If not provided the method retieves
the data automatically by calling the method <a class="reference internal" href="fmu_utils/model.html#estimationpy.fmu_utils.model.Model.get_measured_data_ouputs" title="estimationpy.fmu_utils.model.Model.get_measured_data_ouputs"><code class="xref py py-func docutils literal"><span class="pre">estimationpy.fmu_utils.model.Model.get_measured_data_ouputs()</span></code></a>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p>a tuple with the following variables</p>
<ul class="simple">
<li>a vector containing the corrected state,</li>
<li>the corrected quare root of the state covariance matrix,</li>
<li>the average of the measured outputs,</li>
<li>the square root of the output covariance matrix,</li>
<li>the average of the complete output vector,</li>
<li>the average of the full corrected state vector</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">tuple</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="footnotes">
<h2>Footnotes<a class="headerlink" href="#footnotes" title="Permalink to this headline">¶</a></h2>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[3]</a></td><td><a class="reference external" href="http://www.fmi-standard.org">http://www.fmi-standard.org</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[4]</a></td><td>The sigma-points can be seen as the counterpart of the particles used in Monte Carlo methods.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<table class="docutils citation" frame="void" id="julier1996" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Julier1996]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id11">2</a>, <a class="fn-backref" href="#id12">3</a>, <a class="fn-backref" href="#id14">4</a>)</em> S. J. Julier and J. K. Uhlmann.
A general method for approximating nonlinear transformations of probability distributions.
Robotics Research Group Technical Report, Department of Engineering Science,
University of Oxford, pages 1–27, November 1996.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="haykin2001" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Haykin2001]</td><td><em>(<a class="fn-backref" href="#id7">1</a>, <a class="fn-backref" href="#id8">2</a>)</em> Simon S Haykin et al.
Kalman filtering and neural networks.
Wiley Online Library, 2001</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="doucet2002" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[Doucet2002]</a></td><td>D. Crisan and Arnaud Doucet.
A survey of convergence results on particle filtering methods for practitioners.
Signal Processing, IEEE Transactions on, 50(3):736–746, 2002.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="wanmerwe2000" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[WanMerwe2000]</td><td><em>(<a class="fn-backref" href="#id9">1</a>, <a class="fn-backref" href="#id15">2</a>)</em> E.A. Wan and R. Van der Merwe.
The unscented kalman filter for nonlinear estimation.
In Adaptive Systems for Signal Processing, Communications, and Control Symposium 2000.
AS-SPCC. The IEEE 2000, pages 153–158, 2000.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="julier2002" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[Julier2002]</a></td><td>S.J. Julier.
The scaled unscented transformation.
In American Control Conference, 2002. Proceedings of the 2002,
volume 6, pages 4555–4559 vol.6, 2002.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="sarkka2007" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[Sarkka2007]</a></td><td>S. Sarkka.
On unscented kalman filtering for state estimation of continuous-time nonlinear systems.
Automatic Control, IEEE Transactions on, 52(9):1631–1641, 2007.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="sarkka2008" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Sarkka2008]</td><td><em>(<a class="fn-backref" href="#id5">1</a>, <a class="fn-backref" href="#id16">2</a>)</em> S. Sarkka.
Unscented rauch–tung–striebel smoother.
Automatic Control, IEEE Transactions on, 53(3):845–849, 2008.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="bonvini2014" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[Bonvini2014]</a></td><td>Marco Bonvini, Michael Wetter, Michael D. Sohn
An FMI-based framework for state and parameter estimation
In proceedings of 10th International Modelica Conference, 2014 - p. 647-656, Lund, Sweden
<a class="reference external" href="http://www.ep.liu.se/ecp/096/068/ecp14096068.pdf">http://www.ep.liu.se/ecp/096/068/ecp14096068.pdf</a></td></tr>
</tbody>
</table>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="examples.html" class="btn btn-neutral float-right" title="Examples" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="fmu_utils/strings.html" class="btn btn-neutral" title="Constant strings" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright EstimationPy, Copyright (c) 2015, The Regents of the University of California, through Lawrence Berkeley National Laboratory (subject to receipt of any required approvals from the U.S. Dept. of Energy). All rights reserved..

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.1a',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>